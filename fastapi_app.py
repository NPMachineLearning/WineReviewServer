# -*- coding: utf-8 -*-
"""fastapi_app.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d8vHUf9gNh-ZDxBB39vV1jhw-aiZ713M

# Deploy FastAPI and ML model to Heroku

* https://towardsdatascience.com/how-to-deploy-your-fastapi-app-on-heroku-for-free-8d4271a4ab9

* ⚠️ **Note**: When using **nltk** see here
 * https://devcenter.heroku.com/articles/python-nltk

* run uvicorn on heroku
  * https://stackoverflow.com/questions/59391560/how-to-run-uvicorn-in-heroku

  * https://www.uvicorn.org/deployment/
"""

# #Commnt out when not in colab
# !pip install fastapi nest-asyncio pyngrok uvicorn pydantic typing NumPy pandas
# !cp /content/drive/MyDrive/Colab\ Notebooks/WineReviewPro/predictor.ipynb ./
# !cp /content/drive/MyDrive/Colab\ Notebooks/Data/Wine\ Reviews/trained-model.joblib ./
# !pip install import-ipynb
# import import_ipynb
# #Commnt out when not in colab

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import nest_asyncio
from pyngrok import ngrok
import uvicorn
from pydantic import BaseModel
from typing import Optional
import pandas as pd
import numpy as np
import math
import predictor

# Default page and size
PAGE, SIZE = 1, 10

# WineQuery model
class WineQuery(BaseModel):
  description: str
  page: Optional[int] = PAGE
  size: Optional[int] = SIZE

# AppState response model
class AppStateResponse(BaseModel):
  message: Optional[str] = 'App is running'

# Common response model
class Response(BaseModel):
  total_pages: int
  total_results: int
  page: int
  size: int
  result: list
  server_message: str

# Instantiate predictor
predictor = predictor.WineRecommendor()

# Handle page and size value
def page_size_handler(page, size):
  if page <= 0:
    page = 1
  if size <= 0:
    size = 10

  return page, size

# Handle endpoint response
def reponse_handler(total_pages=0,
                    total_results=0,
                    page=PAGE,
                    size=SIZE,
                    result=[],
                    server_message=""):
  '''
  Handle respond object
  '''
  return Response(total_pages=total_pages,
                  total_results=total_results,
                  page=page,
                  size=size,
                  result=result,
                  server_message=server_message)

# Create APP
app = FastAPI()

# List of CORS
origins = [
    "*"
]

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=False,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/', response_model=AppStateResponse)
async def default() -> AppStateResponse:
  '''
  App is up and runing if successful response
  '''
  return AppStateResponse()

# Return all column names that can be query
@app.get('/all-column-names', response_model=Response)
async def column_list() -> Response:
  '''
  Return a list of column names in data table
  '''
  tags = predictor.get_data_table_col_names()
  return reponse_handler(result=list(tags))


# Return all unique values under specific column name in data table
@app.get('/list-of/', response_model=Response)
async def list_of(column_name: str,
                  page: Optional[int] = PAGE,
                  size: Optional[int] = SIZE) -> Response:
  '''
  Return a list of unique values under a column name
  '''
  column_tags = predictor.get_data_table_col_names()
  if column_name not in column_tags:
    return reponse_handler(server_message=f"column name \"{column_name}\" doesn't exist")

  page, size = page_size_handler(page, size)

  result_series = predictor.get_data_from_table_by(column_name)
  values = result_series.value_counts().index

  total_results = len(values)
  total_pages = math.ceil(total_results / size)
  start_index = (page - 1) * size

  result_records = list(values[start_index:start_index+size])

  return reponse_handler(total_pages,
                         total_results,
                         page, size,
                         result_records)

# Recommend wine
@app.post('/find-wine/', response_model=Response)
async def find_wine(query:WineQuery) -> Response:
  '''
  Predict wine that is similar to description
  '''
  page, size = page_size_handler(query.page, query.size)

  if not query.description or query.description == "" or query.description.isspace():
    return reponse_handler(0, 0, page, size, [], f"description can't be empty")

  result_df = predictor.find_wine_by_desc(query.description)

  total_results = len(result_df)
  total_pages = math.ceil(total_results / size)
  start_index = (page - 1) * size

  result_df = result_df.iloc[start_index:start_index + size]
  result_df = result_df[['country',
                         'description',
                         'province',
                         'region_1',
                         'region_2',
                         'title',
                         'variety',
                         'winery',
                         'points',
                         'price']]

  result_records = result_df.to_dict('records')

  return reponse_handler(total_pages,
                         total_results,
                         page, size,
                         result_records)

from fastapi.openapi.utils import get_openapi

def custom_openapi():
  if app.openapi_schema:
      return app.openapi_schema
  openapi_schema = get_openapi(
      title="Wine recommendation API",
      version="1.0.0",
      description='''
      This API is base on pre-trained machine learning model that is capable of
      predict and recommend variety of wine base on description which given by
      human.

      The description will be analyized through natural language processing and
      then find a list of wines that are similar to description.

      Support language: English

      Example: Given an description to API **find-wine** which is **POST** method to
      find any wines that is similar to your description. The description
      for example:
      **
      90–92. Barrel sample. This is a solid and dense wine with hints of bitter
      chocolate along with super-ripe blackberry fruits.
      The wine has concentration, richness and a fine ageing potential
      **

      -------------------------------------------------------------------------

      API是建立於機器學習模型上, 利用已經學習過的模型來預測和推薦各種不同的酒品. 透過人的感覺
      和敘述, 並利用自然語言分析來分析所給的敘述, 最後利用模型預測和推薦最相近的酒品.

      支援語言: 英文

      例如: 將一串敘述丟給 **find-wine**(POST方式) API 就會回傳任何最相近敘述的酒品.
      敘述範例:
      **
      90–92. Barrel sample. This is a solid and dense wine with hints of bitter
      chocolate along with super-ripe blackberry fruits.
      The wine has concentration, richness and a fine ageing potential
      **
      ''',
      routes=app.routes,
  )
  openapi_schema["info"]["x-logo"] = {
      "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
  }
  app.openapi_schema = openapi_schema
  return app.openapi_schema

app.openapi = custom_openapi

if __name__ == "__main__":
  # #Commnt out when not in colab
  # PORT=8080
  # #Commnt out when not in colab
  # ngrok_tunnel = ngrok.connect(PORT)
  # #Commnt out when not in colab
  # print('Public URL:', ngrok_tunnel.public_url)

  nest_asyncio.apply()

  # #Commnt out when not in colab
  # # Don't run programatically when deploy to server, use command line instead
  # uvicorn.run(app, host="0.0.0.0", port=PORT, log_level="info")